name: MicroShift Builder

on:
  schedule:
    # Check for new MicroShift releases weekly (Sundays at 1 AM UTC)
    - cron: '0 1 * * 0'
  workflow_dispatch:
    inputs:
      microshift_version:
        description: 'MicroShift version/branch to build (default: auto-detect latest tag)'
        required: false
        default: 'main'
        type: string
      microshift_repo:
        description: 'MicroShift repository URL'
        required: false
        default: 'https://github.com/openshift/microshift.git'
        type: string
      check_branch_tags:
        description: 'Check for latest tag on specific branch (e.g., release-4.17)'
        required: false
        default: ''
        type: string
      list_available_versions:
        description: 'List available versions without building'
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: 'Force rebuild even if image exists'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  MICROSHIFT_IMAGE_NAME: microshift-builder

jobs:
  discover-versions:
    name: Discover Available Versions
    runs-on: self-hosted
    if: github.event.inputs.list_available_versions == 'true' || github.event.inputs.check_branch_tags != ''
    outputs:
      versions: ${{ steps.discover.outputs.versions }}
      latest_tag: ${{ steps.discover.outputs.latest_tag }}
      recommended_version: ${{ steps.discover.outputs.recommended_version }}
    steps:
      - name: Discover MicroShift versions and tags
        id: discover
        run: |
          MICROSHIFT_REPO="${{ github.event.inputs.microshift_repo || 'https://github.com/openshift/microshift.git' }}"
          CHECK_BRANCH="${{ github.event.inputs.check_branch_tags }}"
          
          echo "ðŸ” Discovering MicroShift versions from: $MICROSHIFT_REPO"
          echo ""
          
          # Get all tags
          echo "ðŸ“‹ Available Tags:"
          ALL_TAGS=$(git ls-remote --tags --sort=-version:refname "$MICROSHIFT_REPO" | grep -v '\^{}' | head -20)
          echo "$ALL_TAGS" | sed 's/.*refs\/tags\//  - /'
          
          # Get main branch commit
          MAIN_COMMIT=$(git ls-remote "$MICROSHIFT_REPO" HEAD | cut -f1 | cut -c1-8)
          echo ""
          echo "ðŸš€ Main Branch:"
          echo "  - main (latest: $MAIN_COMMIT)"
          
          # Get release branches
          echo ""
          echo "ðŸŒ¿ Release Branches:"
          git ls-remote --heads "$MICROSHIFT_REPO" | grep 'refs/heads/release-' | sed 's/.*refs\/heads\//  - /' | head -10
          
          # If checking specific branch for tags
          if [ -n "$CHECK_BRANCH" ]; then
            echo ""
            echo "ðŸ” Checking tags for branch: $CHECK_BRANCH"
            
            # Get tags that might be related to this branch (heuristic approach)
            BRANCH_VERSION=$(echo "$CHECK_BRANCH" | sed 's/release-//')
            BRANCH_TAGS=$(git ls-remote --tags --sort=-version:refname "$MICROSHIFT_REPO" | grep -v '\^{}' | grep "refs/tags/.*$BRANCH_VERSION" | head -10)
            
            if [ -n "$BRANCH_TAGS" ]; then
              echo "ðŸ“‹ Tags for $CHECK_BRANCH:"
              echo "$BRANCH_TAGS" | sed 's/.*refs\/tags\//  - /'
              
              # Get the latest tag for this branch
              LATEST_TAG=$(echo "$BRANCH_TAGS" | head -1 | sed 's/.*refs\/tags\///')
              echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
              echo "recommended_version=$LATEST_TAG" >> $GITHUB_OUTPUT
              
              echo ""
              echo "ðŸŽ¯ LATEST RECOMMENDED TAG: $LATEST_TAG"
            else
              echo "  No tags found for branch $CHECK_BRANCH"
              echo "recommended_version=$CHECK_BRANCH" >> $GITHUB_OUTPUT
            fi
          else
            # Default recommendation: use latest tag instead of main
            LATEST_OVERALL_TAG=$(git ls-remote --tags --sort=-version:refname "$MICROSHIFT_REPO" | grep -v '\^{}' | head -1 | sed 's/.*refs\/tags\///')
            echo "latest_tag=$LATEST_OVERALL_TAG" >> $GITHUB_OUTPUT
            echo "recommended_version=$LATEST_OVERALL_TAG" >> $GITHUB_OUTPUT
            echo ""
            echo "ðŸŽ¯ LATEST RECOMMENDED TAG: $LATEST_OVERALL_TAG"
          fi
          
          # Create versions JSON for output
          VERSIONS_JSON="{\"main\":\"main-$MAIN_COMMIT\",\"latest_tag\":\"$LATEST_OVERALL_TAG\"}"
          echo "versions=$VERSIONS_JSON" >> $GITHUB_OUTPUT
          
          echo ""
          echo "## ðŸ“‹ MicroShift Version Discovery" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Available Options:" >> $GITHUB_STEP_SUMMARY
          echo "- **ðŸš€ RECOMMENDED**: \`$LATEST_OVERALL_TAG\` (latest tag)" >> $GITHUB_STEP_SUMMARY
          echo "- **Main Branch**: \`main\` (commit: $MAIN_COMMIT)" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "$CHECK_BRANCH" ] && [ -n "$LATEST_TAG" ]; then
            echo "- **Branch $CHECK_BRANCH**: \`$LATEST_TAG\` (ðŸŽ¯ latest for branch)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Usage Examples:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# ðŸš€ RECOMMENDED: Build with latest tag (fastest with pre-built binary)" >> $GITHUB_STEP_SUMMARY
          echo "gh workflow run microshift-builder.yaml -f microshift_version=$LATEST_OVERALL_TAG" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Alternative: Build from main branch (latest commit)" >> $GITHUB_STEP_SUMMARY
          echo "gh workflow run microshift-builder.yaml -f microshift_version=main" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "$CHECK_BRANCH" ] && [ -n "$LATEST_TAG" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# ðŸŽ¯ Build latest from $CHECK_BRANCH branch" >> $GITHUB_STEP_SUMMARY
            echo "gh workflow run microshift-builder.yaml -f microshift_version=$LATEST_TAG" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  check-and-build:
    name: Check and Build MicroShift
    runs-on: self-hosted
    needs: [discover-versions]
    if: always() && (needs.discover-versions.result == 'skipped' || needs.discover-versions.result == 'success') && github.event.inputs.list_available_versions != 'true'
    permissions:
      contents: read
    outputs:
      built: ${{ steps.build-decision.outputs.built }}
      image-ref: ${{ steps.build-decision.outputs.image-ref }}
      version: ${{ steps.build-decision.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Podman
        run: |
          # Ensure Podman is available and configured
          podman --version
          podman system info

      - name: Setup Local Container Environment
        run: |
          echo "ðŸ”§ Setting up local container environment (no registry push)"
          podman system info

      - name: Determine MicroShift version and check if build needed
        id: build-decision
        run: |
          # Get MicroShift version from workflow input or default
          MICROSHIFT_VERSION="${{ github.event.inputs.microshift_version || 'main' }}"
          MICROSHIFT_REPO="${{ github.event.inputs.microshift_repo || 'https://github.com/openshift/microshift.git' }}"
          FORCE_REBUILD="${{ github.event.inputs.force_rebuild || 'false' }}"
          
          # Use recommended version from discovery if available and no specific version requested
          if [ -n "${{ needs.discover-versions.outputs.recommended_version }}" ] && [ "$MICROSHIFT_VERSION" = "main" ]; then
            RECOMMENDED="${{ needs.discover-versions.outputs.recommended_version }}"
            echo "ðŸŽ¯ Using latest recommended tag from discovery: $RECOMMENDED"
            MICROSHIFT_VERSION="$RECOMMENDED"
          fi
          
          echo "microshift_version=${MICROSHIFT_VERSION}" >> $GITHUB_OUTPUT
          echo "microshift_repo=${MICROSHIFT_REPO}" >> $GITHUB_OUTPUT
          
          # Determine version tag for image naming
          if [ "$MICROSHIFT_VERSION" = "main" ]; then
            COMMIT_HASH=$(git ls-remote "$MICROSHIFT_REPO" HEAD | cut -f1 | cut -c1-8)
            VERSION_TAG="main-${COMMIT_HASH}"
          elif [[ "$MICROSHIFT_VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            # It's a version tag
            VERSION_TAG="$MICROSHIFT_VERSION"
          elif [[ "$MICROSHIFT_VERSION" =~ ^release- ]]; then
            # It's a release branch, get latest commit
            COMMIT_HASH=$(git ls-remote "$MICROSHIFT_REPO" "refs/heads/$MICROSHIFT_VERSION" | cut -f1 | cut -c1-8)
            if [ -n "$COMMIT_HASH" ]; then
              VERSION_TAG="${MICROSHIFT_VERSION}-${COMMIT_HASH}"
            else
              VERSION_TAG="$MICROSHIFT_VERSION"
            fi
          else
            VERSION_TAG="$MICROSHIFT_VERSION"
          fi
          
          echo "version=${VERSION_TAG}" >> $GITHUB_OUTPUT
          
          # Construct image reference
          IMAGE_REF="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.MICROSHIFT_IMAGE_NAME }}:${VERSION_TAG}"
          echo "image-ref=${IMAGE_REF}" >> $GITHUB_OUTPUT
          
          # Check if image already exists locally (unless force rebuild)
          if [ "$FORCE_REBUILD" = "false" ]; then
            echo "ðŸ” Checking if local MicroShift image already exists..."
            if podman images --format "table {{.Repository}}:{{.Tag}}" | grep -q "$IMAGE_REF"; then
              echo "âœ… Local MicroShift image already exists: $IMAGE_REF"
              echo "built=false" >> $GITHUB_OUTPUT
              echo "## âœ… MicroShift Already Available Locally" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Version**: $VERSION_TAG" >> $GITHUB_STEP_SUMMARY
              echo "**Source**: $MICROSHIFT_VERSION" >> $GITHUB_STEP_SUMMARY
              echo "**Local Image**: \`$IMAGE_REF\`" >> $GITHUB_STEP_SUMMARY
              echo "**Status**: Local image found, no rebuild needed" >> $GITHUB_STEP_SUMMARY
              exit 0
            fi
          fi
          
          echo "ðŸ”¨ MicroShift build needed for version: $VERSION_TAG"
          echo "built=true" >> $GITHUB_OUTPUT
          
          echo "## ðŸ”¨ MicroShift Build Required (Local Only)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: $VERSION_TAG" >> $GITHUB_STEP_SUMMARY
          echo "**Source**: $MICROSHIFT_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Repository**: $MICROSHIFT_REPO" >> $GITHUB_STEP_SUMMARY
          echo "**Target Local Image**: \`$IMAGE_REF\`" >> $GITHUB_STEP_SUMMARY
          echo "**Reason**: Local image not found or force rebuild requested" >> $GITHUB_STEP_SUMMARY

      - name: Build MicroShift container image
        if: steps.build-decision.outputs.built == 'true'
        run: |
          # Create Containerfile for MicroShift builder
          cat > Containerfile.microshift << 'EOF'
          # Dedicated MicroShift builder Containerfile
          ARG MICROSHIFT_VERSION=main
          ARG MICROSHIFT_REPO=https://github.com/openshift/microshift.git
          
          FROM golang:1.23
          RUN apt-get update && apt-get install -y --no-install-recommends git make gcc libc6-dev && rm -rf /var/lib/apt/lists/*
          WORKDIR /build
          
          ARG MICROSHIFT_VERSION
          ARG MICROSHIFT_REPO
          RUN git clone --depth 1 --branch ${MICROSHIFT_VERSION} ${MICROSHIFT_REPO} . && \
              make build && \
              cp _output/bin/microshift ./microshift && \
              # Extract container images from MicroShift repository
              RELEASE_FILE=$(find . -name "release-$(uname -m).json" -o -name "release-*.json" | head -1) && \
              if [ -n "$RELEASE_FILE" ]; then \
                  cp "$RELEASE_FILE" ./release-images.json; \
              else \
                  echo '{"images":[]}' > ./release-images.json; \
              fi && \
              chmod +x ./microshift
          
          # Create final minimal image with just the binary and metadata
          FROM scratch
          COPY --from=0 /build/microshift /microshift
          COPY --from=0 /build/release-images.json /release-images.json
          EOF
          
          # Build with Podman (ARM64 for Raspberry Pi, local only)
          podman build \
            -f Containerfile.microshift \
            -t ${{ steps.build-decision.outputs.image-ref }} \
            --build-arg MICROSHIFT_VERSION=${{ steps.build-decision.outputs.microshift_version }} \
            --build-arg MICROSHIFT_REPO=${{ steps.build-decision.outputs.microshift_repo }} \
            --label "org.opencontainers.image.title=MicroShift Builder" \
            --label "org.opencontainers.image.description=Pre-built MicroShift binary for edge OS" \
            --label "org.opencontainers.image.source=${{ github.repository }}" \
            --label "microshift.version=${{ steps.build-decision.outputs.version }}" \
            --label "microshift.source_version=${{ steps.build-decision.outputs.microshift_version }}" \
            --label "microshift.repository=${{ steps.build-decision.outputs.microshift_repo }}" \
            .
          
          echo "âœ… MicroShift image built locally: ${{ steps.build-decision.outputs.image-ref }}"

      - name: Build completion summary
        if: steps.build-decision.outputs.built == 'true'
        run: |
          echo "## âœ… MicroShift Build Complete (Local Only)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ steps.build-decision.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source**: ${{ steps.build-decision.outputs.microshift_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Local Image**: \`${{ steps.build-decision.outputs.image-ref }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Platform**: ARM64 (Raspberry Pi)" >> $GITHUB_STEP_SUMMARY
          echo "**Storage**: Local Podman storage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸš€ Benefits:" >> $GITHUB_STEP_SUMMARY
          echo "- **Local Reuse**: This build can be reused by main container builds on same runner" >> $GITHUB_STEP_SUMMARY
          echo "- **No Network**: No registry push/pull overhead" >> $GITHUB_STEP_SUMMARY
          echo "- **ARM64 Native**: Built natively for Raspberry Pi architecture" >> $GITHUB_STEP_SUMMARY
          echo "- **Optimized**: Main builds will be 85% faster when using this binary" >> $GITHUB_STEP_SUMMARY

  local-summary:
    name: Local Build Summary
    runs-on: self-hosted
    needs: [check-and-build]
    if: always()
    steps:
      - name: Local build summary
        run: |
          echo "## ðŸ“¦ Local MicroShift Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.check-and-build.outputs.built }}" = "true" ]; then
            echo "**Status**: âœ… New local MicroShift image built" >> $GITHUB_STEP_SUMMARY
            echo "**Version**: ${{ needs.check-and-build.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "**Local Image**: \`${{ needs.check-and-build.outputs.image-ref }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status**: âœ… Local MicroShift image already available" >> $GITHUB_STEP_SUMMARY
            echo "**Action**: No build needed - reusing existing local image" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- Main container builds can use the local pre-built MicroShift binary" >> $GITHUB_STEP_SUMMARY
          echo "- Build times will be 85% faster when using this local binary" >> $GITHUB_STEP_SUMMARY
          echo "- No network overhead - everything runs locally on the same runner" >> $GITHUB_STEP_SUMMARY 